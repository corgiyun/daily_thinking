文章来源：阮一峰《ES6 标准入门第二版》

### 1、let 命令
#### 1.1 基本用法
let 命令，用于声明变量。其用法类似var，但是所声明的变量只在let命令所在的代码块有效。
```js
{
   let a = 10;
   var b = 1; 
}

a // ReferenceError: a is no defined
b // 1
```
上面的代码分别使用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表情，let声明的变量只在其所在代码块有效。

for循环的计数器，就合适用let命令。以下代码如果使用var，最终将输出10
```js
var a = [];
for(var i = 0; i < 10; i++) {
    a[i] = functin() {
        console.log(i)
    }
}
a[6](); // 10
```
上面的代码中，每一次循环i都会覆盖旧值，导致最后输出的是最后一轮的i。
如果使用let，声明的变量仅在块级作用域内有效，最后将输出6
```js
var a = [];
for(let i = 0; i < 10; i++) {
    a[i] = functin() {
        console.log(i)
    }
}
a[6](); // 6
```
上面的代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，于是最后输出的是6。

#### 1.2 不存在变量提升 
let不像var一样会发生变量提升，所以，变量一定要在声明后使用，否则会报错。
```js
console.log(foo); // ReferencenError
let foo = 1;
```
上面的代码在声明foo之前就使用了这个变量，结果会抛出一个错误。

#### 1.3 暂时性死区
只要块级作用域内存在let命令，它所声明的变量就绑定这个区域，不再受外部的影响
```js
var tmp = 123;
if (true) {
    tmp = 'abc'; // Reference Error
    let tmp;
}
```
上面的代码中存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值就会报错。

ES6明确规定，如果区块中存在let和const命令，则这个区块对这些命令声明的变量从一开始就形成封闭作用域，只要在声明之前就使用这些变量，就会报错。

总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上称为“暂时性死区”(temporal dead zone，简称TDZ)。
